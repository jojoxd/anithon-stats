// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: lists.sql

package postgres

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createList = `-- name: CreateList :execresult
INSERT INTO lists
    (id, user_id, name)
VALUES
    ($1, $2, $3)
RETURNING id
`

type CreateListParams struct {
	Id     uuid.UUID
	UserID uuid.UUID
	Name   string
}

func (q *Queries) CreateList(ctx context.Context, arg CreateListParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createList, arg.Id, arg.UserID, arg.Name)
}

const deleteList = `-- name: DeleteList :exec
DELETE FROM lists l
WHERE
    l.id = $1
`

func (q *Queries) DeleteList(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteList, id)
	return err
}

const getList = `-- name: GetList :one
SELECT
    ls.list_id,
    l.id, l.user_id, l.name, l.created_at, l.updated_at
FROM
    lists l
LEFT JOIN list_settings ls
    ON ls.list_id = l.id
WHERE
    l.id = $1
`

type GetListRow struct {
	ListSetting ListSetting
	Id          uuid.UUID
	UserID      uuid.UUID
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) GetList(ctx context.Context, id uuid.UUID) (GetListRow, error) {
	row := q.db.QueryRowContext(ctx, getList, id)
	var i GetListRow
	err := row.Scan(
		&i.ListSetting.ListID,
		&i.Id,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserLists = `-- name: GetUserLists :many
SELECT
    ls.list_id,
    l.id, l.user_id, l.name, l.created_at, l.updated_at
FROM
    lists l
LEFT JOIN list_settings ls
    ON ls.list_id = l.id
WHERE
    l.user_id = $1
`

type GetUserListsRow struct {
	ListSetting ListSetting
	Id          uuid.UUID
	UserID      uuid.UUID
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) GetUserLists(ctx context.Context, userID uuid.UUID) ([]GetUserListsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserLists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserListsRow
	for rows.Next() {
		var i GetUserListsRow
		if err := rows.Scan(
			&i.ListSetting.ListID,
			&i.Id,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLists = `-- name: SearchLists :many
SELECT
    ls.list_id,
    l.id, l.user_id, l.name, l.created_at, l.updated_at
FROM
    lists l
LEFT JOIN list_settings ls
    ON ls.list_id = l.id
WHERE
    l.name LIKE $1
`

type SearchListsRow struct {
	ListSetting ListSetting
	Id          uuid.UUID
	UserID      uuid.UUID
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) SearchLists(ctx context.Context, name string) ([]SearchListsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchLists, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchListsRow
	for rows.Next() {
		var i SearchListsRow
		if err := rows.Scan(
			&i.ListSetting.ListID,
			&i.Id,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUserLists = `-- name: SearchUserLists :many
SELECT
    ls.list_id,
    l.id, l.user_id, l.name, l.created_at, l.updated_at
FROM
    lists l
INNER JOIN list_settings ls
    ON ls.list_id = l.id
WHERE
    l.user_id = $1
AND
    l.name LIKE $2
`

type SearchUserListsParams struct {
	UserID uuid.UUID
	Name   string
}

type SearchUserListsRow struct {
	ListSetting ListSetting
	Id          uuid.UUID
	UserID      uuid.UUID
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) SearchUserLists(ctx context.Context, arg SearchUserListsParams) ([]SearchUserListsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchUserLists, arg.UserID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUserListsRow
	for rows.Next() {
		var i SearchUserListsRow
		if err := rows.Scan(
			&i.ListSetting.ListID,
			&i.Id,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateList = `-- name: UpdateList :exec
UPDATE lists
SET
    name = $2
WHERE
    id = $1
`

type UpdateListParams struct {
	Id   uuid.UUID
	Name string
}

func (q *Queries) UpdateList(ctx context.Context, arg UpdateListParams) error {
	_, err := q.db.ExecContext(ctx, updateList, arg.Id, arg.Name)
	return err
}
